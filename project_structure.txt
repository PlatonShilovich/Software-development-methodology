- software-development-methodology
	- .eslintrc.yml:
		parser: "@typescript-eslint/parser"
		parserOptions:
		  ecmaVersion: 2020
		  sourceType: module
		  project: ./tsconfig.json # Для правил TypeScript
		extends:
		  - standard-with-typescript # Базовые правила для TypeScript
		  - prettier # Интеграция с Prettier
		plugins:
		  - "@typescript-eslint" # Поддержка TypeScript
		ignorePatterns:
		  - node_modules # Игнорируем node_modules
		  - dist # Игнорируем скомпилированные файлы
		  - "*.config.js" # Игнорируем конфигурационные файлы
		rules:
		  no-console: off # Разрешить console.log для CLI
		  import/extensions: off # Разрешить импорт без расширений
		  # Настройки порядка импорта
		  "import/order":
		    - error
		    - groups:
		        - ["builtin", "external"] # Базовые и внешние модули
		        - "internal" # Внутренние модули
		        - ["sibling", "parent"] # Импорты из соседних и родительских файлов
		        - "index" # Импорт из index файлов
		      alphabetize:
		        order: "asc" # Сортировать по алфавиту
		        caseInsensitive: true # Игнорировать регистр
		  # Обеспечение единообразных типов
		  "@typescript-eslint/consistent-type-definitions":
		    - error
		    - "type"
		  # Отключение избыточно строгих правил для CLI
		  "@typescript-eslint/strict-boolean-expressions": off
		  "@typescript-eslint/prefer-nullish-coalescing": off
		  "@typescript-eslint/explicit-function-return-type": off
		  "@typescript-eslint/restrict-template-expressions": off
		  "@typescript-eslint/triple-slash-reference": off
		  "@typescript-eslint/ban-types": off
		  "@typescript-eslint/consistent-type-assertions": off
		  # Обязательные фигурные скобки
		  curly:
		    - error
		    - all
		  # Запрет неровных пробелов
		  no-irregular-whitespace:
		    - error
		    - skipTemplates: true
		      skipStrings: true

	- .git
		- hooks
		- info
		- logs
			- refs
				- heads
				- remotes
					- origin
		- objects
			- 02
			- 23
			- 34
			- 3c
			- 3d
			- 3f
			- 49
			- 4b
			- 5a
			- 6c
			- 76
			- 81
			- 84
			- 8b
			- 8c
			- 90
			- a4
			- a5
			- b0
			- b2
			- b9
			- c2
			- cd
			- d4
			- db
			- f6
			- info
			- pack
		- refs
			- heads
			- remotes
				- origin
			- tags
	- dist
		- script.js:
		"use strict";
		var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
		    if (k2 === undefined) k2 = k;
		    var desc = Object.getOwnPropertyDescriptor(m, k);
		    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
		      desc = { enumerable: true, get: function() { return m[k]; } };
		    }
		    Object.defineProperty(o, k2, desc);
		}) : (function(o, m, k, k2) {
		    if (k2 === undefined) k2 = k;
		    o[k2] = m[k];
		}));
		var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
		    Object.defineProperty(o, "default", { enumerable: true, value: v });
		}) : function(o, v) {
		    o["default"] = v;
		});
		var __importStar = (this && this.__importStar) || (function () {
		    var ownKeys = function(o) {
		        ownKeys = Object.getOwnPropertyNames || function (o) {
		            var ar = [];
		            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
		            return ar;
		        };
		        return ownKeys(o);
		    };
		    return function (mod) {
		        if (mod && mod.__esModule) return mod;
		        var result = {};
		        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
		        __setModuleDefault(result, mod);
		        return result;
		    };
		})();
		Object.defineProperty(exports, "__esModule", { value: true });
		const fs = __importStar(require("fs"));
		const path = __importStar(require("path"));
		const projectPath = path.resolve('/Users/platon/software-development-methodology'); // Путь к проекту
		const outputFilePath = path.join('/Users/platon/software-development-methodology', 'project_structure.txt'); // Выходной файл
		const includeExtensions = ['.ts', '.js', '.md', '.tsx', '.prisma', 'scss', 'json', 'yml']; // Фильтр по расширениям
		const ignoreFolders = ['node_modules']; // Игнорируемые папки
		const ignoreFiles = ['README.md', 'exportProject.ts', 'package-lock.json']; // Файлы, которые НЕ должны записываться
		// Функция для рекурсивного обхода файлов
		function readFilesRecursively(dir, prefix = '-') {
		    let output = `${prefix} ${path.basename(dir)}\n`;
		    const files = fs.readdirSync(dir);
		    for (const file of files) {
		        const filePath = path.join(dir, file);
		        const stat = fs.statSync(filePath);
		        if (stat.isDirectory()) {
		            if (!ignoreFolders.includes(file)) {
		                output += readFilesRecursively(filePath, `\t${prefix}`);
		            }
		        }
		        else if (includeExtensions.some((ext) => file.endsWith(ext))
		            && !ignoreFiles.includes(file) // Проверка, чтобы файл не был в списке игнорируемых
		        ) {
		            const content = fs.readFileSync(filePath, 'utf8');
		            output += `\t${prefix} ${file}:\n`;
		            output
		                += `${content
		                    .split('\n')
		                    .map((line) => `\t\t${line}`)
		                    .join('\n')}\n\n`;
		        }
		    }
		    return output;
		}
		// Читаем структуру проекта и записываем в файл
		const projectStructure = readFilesRecursively(projectPath);
		fs.writeFileSync(outputFilePath, projectStructure, 'utf8');
		console.log(`Файл с содержимым проекта сохранен: ${outputFilePath}`);
		

		- src
			- engine.js:
		"use strict";
		var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
		    if (k2 === undefined) k2 = k;
		    var desc = Object.getOwnPropertyDescriptor(m, k);
		    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
		      desc = { enumerable: true, get: function() { return m[k]; } };
		    }
		    Object.defineProperty(o, k2, desc);
		}) : (function(o, m, k, k2) {
		    if (k2 === undefined) k2 = k;
		    o[k2] = m[k];
		}));
		var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
		    Object.defineProperty(o, "default", { enumerable: true, value: v });
		}) : function(o, v) {
		    o["default"] = v;
		});
		var __importStar = (this && this.__importStar) || (function () {
		    var ownKeys = function(o) {
		        ownKeys = Object.getOwnPropertyNames || function (o) {
		            var ar = [];
		            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
		            return ar;
		        };
		        return ownKeys(o);
		    };
		    return function (mod) {
		        if (mod && mod.__esModule) return mod;
		        var result = {};
		        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
		        __setModuleDefault(result, mod);
		        return result;
		    };
		})();
		var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
		    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
		    return new (P || (P = Promise))(function (resolve, reject) {
		        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
		        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
		        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
		        step((generator = generator.apply(thisArg, _arguments || [])).next());
		    });
		};
		Object.defineProperty(exports, "__esModule", { value: true });
		exports.runGame = runGame;
		const readline = __importStar(require("readline"));
		const rl = readline.createInterface({
		    input: process.stdin,
		    output: process.stdout,
		});
		function askQuestion(query) {
		    return new Promise((resolve) => {
		        rl.question(query, (answer) => {
		            resolve(answer);
		        });
		    });
		}
		function runGame(gameDescription, generateQuestionAndAnswer) {
		    return __awaiter(this, void 0, void 0, function* () {
		        console.log('Welcome to the Brain Games!');
		        const name = yield askQuestion('May I have your name? ');
		        console.log(`Hello, ${name}!`);
		        console.log(gameDescription);
		        let correctAnswers = 0;
		        while (correctAnswers < 3) {
		            const { question, answer } = generateQuestionAndAnswer();
		            console.log(`Question: ${question}`);
		            const userAnswer = yield askQuestion('Your answer: ');
		            if (userAnswer.trim() === answer) {
		                console.log('Correct!');
		                correctAnswers += 1;
		            }
		            else {
		                console.log(`'${userAnswer}' is wrong answer ;(. Correct answer was '${answer}'.`);
		                console.log(`Let's try again, ${name}!`);
		                break;
		            }
		        }
		        if (correctAnswers === 3) {
		            console.log(`Congratulations, ${name}!`);
		        }
		        rl.close();
		    });
		}
		

			- game1.js:
		"use strict";
		var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
		    if (k2 === undefined) k2 = k;
		    var desc = Object.getOwnPropertyDescriptor(m, k);
		    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
		      desc = { enumerable: true, get: function() { return m[k]; } };
		    }
		    Object.defineProperty(o, k2, desc);
		}) : (function(o, m, k, k2) {
		    if (k2 === undefined) k2 = k;
		    o[k2] = m[k];
		}));
		var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
		    Object.defineProperty(o, "default", { enumerable: true, value: v });
		}) : function(o, v) {
		    o["default"] = v;
		});
		var __importStar = (this && this.__importStar) || (function () {
		    var ownKeys = function(o) {
		        ownKeys = Object.getOwnPropertyNames || function (o) {
		            var ar = [];
		            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
		            return ar;
		        };
		        return ownKeys(o);
		    };
		    return function (mod) {
		        if (mod && mod.__esModule) return mod;
		        var result = {};
		        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
		        __setModuleDefault(result, mod);
		        return result;
		    };
		})();
		var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
		    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
		    return new (P || (P = Promise))(function (resolve, reject) {
		        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
		        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
		        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
		        step((generator = generator.apply(thisArg, _arguments || [])).next());
		    });
		};
		Object.defineProperty(exports, "__esModule", { value: true });
		const readline = __importStar(require("readline"));
		const rl = readline.createInterface({
		    input: process.stdin,
		    output: process.stdout,
		});
		function askQuestion(query) {
		    return new Promise((resolve) => {
		        rl.question(query, (answer) => {
		            resolve(answer);
		        });
		    });
		}
		function gcd(a, b) {
		    let x = a;
		    let y = b;
		    while (y !== 0) {
		        const temp = y;
		        y = x % y;
		        x = temp;
		    }
		    return x;
		}
		function lcm(a, b) {
		    return (a * b) / gcd(a, b);
		}
		function calculateLCM(a, b, c) {
		    return lcm(lcm(a, b), c);
		}
		function main() {
		    return __awaiter(this, void 0, void 0, function* () {
		        console.log('Welcome to the Brain Games!');
		        const name = yield askQuestion('May I have your name? ');
		        console.log(`Hello, ${name}!`);
		        console.log('Find the smallest common multiple of given numbers.');
		        let correctAnswers = 0;
		        while (correctAnswers < 3) {
		            const num1 = Math.floor(Math.random() * 100) + 1;
		            const num2 = Math.floor(Math.random() * 100) + 1;
		            const num3 = Math.floor(Math.random() * 100) + 1;
		            const question = `Question: ${num1} ${num2} ${num3}\nYour answer: `;
		            // eslint-disable-next-line no-await-in-loop
		            const userAnswer = yield askQuestion(question);
		            const correctAnswer = calculateLCM(num1, num2, num3).toString();
		            if (userAnswer === correctAnswer) {
		                console.log('Correct!');
		                correctAnswers += 1;
		            }
		            else {
		                console.log(`'${userAnswer}' is wrong answer ;(. Correct answer was '${correctAnswer}'.`);
		                console.log(`Let's try again, ${name}!`);
		                break;
		            }
		        }
		        if (correctAnswers === 3) {
		            console.log(`Congratulations, ${name}!`);
		        }
		        rl.close();
		    });
		}
		main();
		

			- game2.js:
		"use strict";
		var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
		    if (k2 === undefined) k2 = k;
		    var desc = Object.getOwnPropertyDescriptor(m, k);
		    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
		      desc = { enumerable: true, get: function() { return m[k]; } };
		    }
		    Object.defineProperty(o, k2, desc);
		}) : (function(o, m, k, k2) {
		    if (k2 === undefined) k2 = k;
		    o[k2] = m[k];
		}));
		var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
		    Object.defineProperty(o, "default", { enumerable: true, value: v });
		}) : function(o, v) {
		    o["default"] = v;
		});
		var __importStar = (this && this.__importStar) || (function () {
		    var ownKeys = function(o) {
		        ownKeys = Object.getOwnPropertyNames || function (o) {
		            var ar = [];
		            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
		            return ar;
		        };
		        return ownKeys(o);
		    };
		    return function (mod) {
		        if (mod && mod.__esModule) return mod;
		        var result = {};
		        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
		        __setModuleDefault(result, mod);
		        return result;
		    };
		})();
		var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
		    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
		    return new (P || (P = Promise))(function (resolve, reject) {
		        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
		        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
		        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
		        step((generator = generator.apply(thisArg, _arguments || [])).next());
		    });
		};
		Object.defineProperty(exports, "__esModule", { value: true });
		const readline = __importStar(require("readline"));
		// Create readline interface for console input/output
		const rl = readline.createInterface({
		    input: process.stdin,
		    output: process.stdout,
		});
		// Function to generate a geometric progression
		function generateProgression(start, ratio, length) {
		    const progression = [];
		    let current = start;
		    for (let i = 0; i < length; i += 1) { // Fixed: i++ replaced with i += 1
		        progression.push(current);
		        current *= ratio;
		    }
		    return progression;
		}
		// Function to ask a question and get the player's response
		function askQuestion(query) {
		    return new Promise((resolve) => {
		        rl.question(query, (answer) => {
		            resolve(answer);
		        });
		    });
		}
		// Function to generate a question with a hidden number
		function generateQuestion() {
		    const length = Math.floor(Math.random() * 6) + 5; // Random length between 5 and 10
		    const start = Math.floor(Math.random() * 10) + 1; // Starting number between 1 and 10
		    const ratio = Math.floor(Math.random() * 4) + 2; // Common ratio between 2 and 5
		    const progression = generateProgression(start, ratio, length);
		    const hiddenIndex = Math.floor(Math.random() * length); // Random position to hide
		    const displayProgression = progression
		        .map((num, index) => (index === hiddenIndex ? '..' : num.toString()))
		        .join(' ');
		    const correctAnswer = progression[hiddenIndex].toString();
		    return { question: displayProgression, answer: correctAnswer };
		}
		// Main game function
		function playGame() {
		    return __awaiter(this, void 0, void 0, function* () {
		        console.log('Welcome to the Brain Games!');
		        const name = yield askQuestion('May I have your name? ');
		        console.log(`Hello, ${name}!`);
		        console.log('What number is missing in the progression?');
		        // Recursive function to ask questions
		        const askNextQuestion = (round) => __awaiter(this, void 0, void 0, function* () {
		            if (round > 3) {
		                console.log(`Congratulations, ${name}!`);
		                rl.close();
		                return;
		            }
		            const { question, answer } = generateQuestion();
		            console.log(`Question: ${question}`);
		            const userAnswer = (yield askQuestion('Your answer: ')).trim();
		            if (userAnswer === answer) {
		                console.log('Correct!');
		                yield askNextQuestion(round + 1);
		            }
		            else {
		                console.log(`'${userAnswer}' is wrong answer ;(. Correct answer was '${answer}'.`);
		                console.log(`Let's try again, ${name}!`);
		                rl.close();
		            }
		        });
		        // Start the game with the first question
		        yield askNextQuestion(1);
		    });
		}
		// Start the game and handle potential errors
		playGame().catch(console.error);
		

			- games
				- game1.js:
		"use strict";
		Object.defineProperty(exports, "__esModule", { value: true });
		exports.gameDescription = void 0;
		exports.generateQuestionAndAnswer = generateQuestionAndAnswer;
		function gcd(a, b) {
		    let x = a;
		    let y = b;
		    while (y !== 0) {
		        const temp = y;
		        y = x % y;
		        x = temp;
		    }
		    return x;
		}
		function lcm(a, b) {
		    return (a * b) / gcd(a, b);
		}
		function calculateLCM(a, b, c) {
		    return lcm(lcm(a, b), c);
		}
		exports.gameDescription = 'Find the smallest common multiple of given numbers.';
		function generateQuestionAndAnswer() {
		    const num1 = Math.floor(Math.random() * 100) + 1;
		    const num2 = Math.floor(Math.random() * 100) + 1;
		    const num3 = Math.floor(Math.random() * 100) + 1;
		    const question = `${num1} ${num2} ${num3}`;
		    const answer = calculateLCM(num1, num2, num3).toString();
		    return { question, answer };
		}
		

				- game2.js:
		"use strict";
		Object.defineProperty(exports, "__esModule", { value: true });
		exports.gameDescription = void 0;
		exports.generateQuestionAndAnswer = generateQuestionAndAnswer;
		function generateProgression(start, ratio, length) {
		    const progression = [];
		    let current = start;
		    for (let i = 0; i < length; i += 1) {
		        progression.push(current);
		        current *= ratio;
		    }
		    return progression;
		}
		exports.gameDescription = 'What number is missing in the progression?';
		function generateQuestionAndAnswer() {
		    const length = Math.floor(Math.random() * 6) + 5; // От 5 до 10 чисел
		    const start = Math.floor(Math.random() * 10) + 1; // Начало от 1 до 10
		    const ratio = Math.floor(Math.random() * 4) + 2; // Коэффициент от 2 до 5
		    const progression = generateProgression(start, ratio, length);
		    const hiddenIndex = Math.floor(Math.random() * length);
		    const question = progression
		        .map((num, index) => (index === hiddenIndex ? '..' : num.toString()))
		        .join(' ');
		    const answer = progression[hiddenIndex].toString();
		    return { question, answer };
		}
		

			- index.js:
		"use strict";
		Object.defineProperty(exports, "__esModule", { value: true });
		const engine_1 = require("./engine");
		const game1_1 = require("./games/game1");
		// Запуск игры "НОК"
		(0, engine_1.runGame)(game1_1.gameDescription, game1_1.generateQuestionAndAnswer);
		// Если хочешь запустить "Геометрическую прогрессию", закомментируй строку выше и раскомментируй эту:
		// runGame(game2Description, generateGame2);
		

	- package.json:
		{
		  "name": "software-development-methodology",
		  "version": "1.0.0",
		  "main": "index.js",
		  "scripts": {
		    "lint": "eslint . --ext .ts",
		    "test": "echo \"Error: no test specified\" && exit 1",
		    "build": "tsc",
		    "start": "node dist/src/index.js"
		  },
		  "keywords": [],
		  "author": "",
		  "license": "ISC",
		  "description": "",
		  "devDependencies": {
		    "@typescript-eslint/eslint-plugin": "^6.21.0",
		    "@typescript-eslint/parser": "^6.21.0",
		    "eslint": "^8.57.1",
		    "eslint-config-prettier": "^10.1.1",
		    "eslint-config-standard-with-typescript": "^43.0.1",
		    "eslint-plugin-import": "^2.31.0",
		    "prettier": "^3.5.3",
		    "typescript": "^5.8.2"
		  }
		}
		

	- script.js:
		"use strict";
		Object.defineProperty(exports, "__esModule", { value: true });
		var fs = require("fs");
		var path = require("path");
		var projectPath = path.resolve('/Users/platon/software-development-methodology'); // Путь к проекту
		var outputFilePath = path.join('/Users/platon/software-development-methodology', 'project_structure.txt'); // Выходной файл
		var includeExtensions = ['.ts', '.js', '.md', '.tsx', '.prisma', 'scss', 'json', 'yml']; // Фильтр по расширениям
		var ignoreFolders = ['node_modules']; // Игнорируемые папки
		var ignoreFiles = ['README.md', 'exportProject.ts', 'package-lock.json']; // Файлы, которые НЕ должны записываться
		// Функция для рекурсивного обхода файлов
		function readFilesRecursively(dir, prefix) {
		    if (prefix === void 0) { prefix = '-'; }
		    var output = "".concat(prefix, " ").concat(path.basename(dir), "\n");
		    var files = fs.readdirSync(dir);
		    var _loop_1 = function (file) {
		        var filePath = path.join(dir, file);
		        var stat = fs.statSync(filePath);
		        if (stat.isDirectory()) {
		            if (!ignoreFolders.includes(file)) {
		                output += readFilesRecursively(filePath, "\t".concat(prefix));
		            }
		        }
		        else if (includeExtensions.some(function (ext) { return file.endsWith(ext); })
		            && !ignoreFiles.includes(file) // Проверка, чтобы файл не был в списке игнорируемых
		        ) {
		            var content = fs.readFileSync(filePath, 'utf8');
		            output += "\t".concat(prefix, " ").concat(file, ":\n");
		            output
		                += "".concat(content
		                    .split('\n')
		                    .map(function (line) { return "\t\t".concat(line); })
		                    .join('\n'), "\n\n");
		        }
		    };
		    for (var _i = 0, files_1 = files; _i < files_1.length; _i++) {
		        var file = files_1[_i];
		        _loop_1(file);
		    }
		    return output;
		}
		// Читаем структуру проекта и записываем в файл
		var projectStructure = readFilesRecursively(projectPath);
		fs.writeFileSync(outputFilePath, projectStructure, 'utf8');
		console.log("\u0424\u0430\u0439\u043B \u0441 \u0441\u043E\u0434\u0435\u0440\u0436\u0438\u043C\u044B\u043C \u043F\u0440\u043E\u0435\u043A\u0442\u0430 \u0441\u043E\u0445\u0440\u0430\u043D\u0435\u043D: ".concat(outputFilePath));
		

	- script.ts:
		import * as fs from 'fs';
		import * as path from 'path';
		
		const projectPath = path.resolve('/Users/platon/software-development-methodology'); // Путь к проекту
		const outputFilePath = path.join('/Users/platon/software-development-methodology', 'project_structure.txt'); // Выходной файл
		const includeExtensions = ['.ts', '.js', '.md', '.tsx', '.prisma', 'scss', 'json', 'yml']; // Фильтр по расширениям
		const ignoreFolders = ['node_modules']; // Игнорируемые папки
		const ignoreFiles = ['README.md', 'exportProject.ts', 'package-lock.json']; // Файлы, которые НЕ должны записываться
		
		// Функция для рекурсивного обхода файлов
		function readFilesRecursively(dir: string, prefix: string = '-'): string {
		  let output = `${prefix} ${path.basename(dir)}\n`;
		
		  const files = fs.readdirSync(dir);
		
		  for (const file of files) {
		    const filePath = path.join(dir, file);
		    const stat = fs.statSync(filePath);
		
		    if (stat.isDirectory()) {
		      if (!ignoreFolders.includes(file)) {
		        output += readFilesRecursively(filePath, `\t${prefix}`);
		      }
		    } else if (
		      includeExtensions.some((ext) => file.endsWith(ext))
		      && !ignoreFiles.includes(file) // Проверка, чтобы файл не был в списке игнорируемых
		    ) {
		      const content = fs.readFileSync(filePath, 'utf8');
		      output += `\t${prefix} ${file}:\n`;
		      output
		        += `${content
		          .split('\n')
		          .map((line) => `\t\t${line}`)
		          .join('\n')}\n\n`;
		    }
		  }
		
		  return output;
		}
		
		// Читаем структуру проекта и записываем в файл
		const projectStructure = readFilesRecursively(projectPath);
		fs.writeFileSync(outputFilePath, projectStructure, 'utf8');
		
		console.log(`Файл с содержимым проекта сохранен: ${outputFilePath}`);
		

	- src
		- engine.ts:
		import * as readline from 'readline';
		
		const rl = readline.createInterface({
		  input: process.stdin,
		  output: process.stdout,
		});
		
		function askQuestion(query: string): Promise<string> {
		  return new Promise((resolve) => {
		    rl.question(query, (answer) => {
		      resolve(answer);
		    });
		  });
		}
		
		export async function runGame(
		  gameDescription: string,
		  generateQuestionAndAnswer: () => { question: string; answer: string },
		) {
		  console.log('Welcome to the Brain Games!');
		  const name = await askQuestion('May I have your name? ');
		  console.log(`Hello, ${name}!`);
		  console.log(gameDescription);
		
		  let correctAnswers = 0;
		  while (correctAnswers < 3) {
		    const { question, answer } = generateQuestionAndAnswer();
		    console.log(`Question: ${question}`);
		    const userAnswer = await askQuestion('Your answer: ');
		
		    if (userAnswer.trim() === answer) {
		      console.log('Correct!');
		      correctAnswers += 1;
		    } else {
		      console.log(
		        `'${userAnswer}' is wrong answer ;(. Correct answer was '${answer}'.`,
		      );
		      console.log(`Let's try again, ${name}!`);
		      break;
		    }
		  }
		
		  if (correctAnswers === 3) {
		    console.log(`Congratulations, ${name}!`);
		  }
		  rl.close();
		}
		

		- games
			- game1.ts:
		function gcd(a: number, b: number): number {
		  let x = a;
		  let y = b;
		  while (y !== 0) {
		    const temp = y;
		    y = x % y;
		    x = temp;
		  }
		  return x;
		}
		
		function lcm(a: number, b: number): number {
		  return (a * b) / gcd(a, b);
		}
		
		function calculateLCM(a: number, b: number, c: number): number {
		  return lcm(lcm(a, b), c);
		}
		
		export const gameDescription = 'Find the smallest common multiple of given numbers.';
		
		export function generateQuestionAndAnswer(): { question: string; answer: string } {
		  const num1 = Math.floor(Math.random() * 100) + 1;
		  const num2 = Math.floor(Math.random() * 100) + 1;
		  const num3 = Math.floor(Math.random() * 100) + 1;
		  const question = `${num1} ${num2} ${num3}`;
		  const answer = calculateLCM(num1, num2, num3).toString();
		  return { question, answer };
		}
		

			- game2.ts:
		function generateProgression(start: number, ratio: number, length: number): number[] {
		  const progression: number[] = [];
		  let current = start;
		  for (let i = 0; i < length; i += 1) {
		    progression.push(current);
		    current *= ratio;
		  }
		  return progression;
		}
		
		export const gameDescription = 'What number is missing in the progression?';
		
		export function generateQuestionAndAnswer(): { question: string; answer: string } {
		  const length = Math.floor(Math.random() * 6) + 5; // От 5 до 10 чисел
		  const start = Math.floor(Math.random() * 10) + 1; // Начало от 1 до 10
		  const ratio = Math.floor(Math.random() * 4) + 2; // Коэффициент от 2 до 5
		  const progression = generateProgression(start, ratio, length);
		  const hiddenIndex = Math.floor(Math.random() * length);
		  const question = progression
		    .map((num, index) => (index === hiddenIndex ? '..' : num.toString()))
		    .join(' ');
		  const answer = progression[hiddenIndex].toString();
		  return { question, answer };
		}
		

		- index.ts:
		import { runGame } from './engine';
		import { gameDescription as game1Description, generateQuestionAndAnswer as generateGame1 } from './games/game1';
		import { gameDescription as game2Description, generateQuestionAndAnswer as generateGame2 } from './games/game2';
		
		// Запуск игры "НОК"
		// runGame(game1Description, generateGame1);
		
		// Если хочешь запустить "Геометрическую прогрессию", закомментируй строку выше и раскомментируй эту:
		runGame(game2Description, generateGame2);
		

	- tsconfig.json:
		{
		  "compilerOptions": {
		    "target": "ES6",
		    "module": "commonjs",
		    "outDir": "./dist",
		    "rootDir": "./",
		    "strict": true,
		    "esModuleInterop": true
		  }
		}
		

